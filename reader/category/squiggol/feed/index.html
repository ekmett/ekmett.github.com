<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>The Comonad.Reader &#187; Squiggol</title>
	<atom:link href="http://comonad.com/reader/category/squiggol/feed/" rel="self" type="application/rss+xml" />
	<link>http://comonad.com/reader</link>
	<description>types, (co)monads, substructural logic</description>
	<lastBuildDate>Thu, 02 May 2013 14:19:12 +0000</lastBuildDate>
	<generator>http://wordpress.org/?v=2.8.4</generator>
	<language>en</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
			<item>
		<title>Reflecting On Incremental Folds</title>
		<link>http://comonad.com/reader/2009/incremental-folds/</link>
		<comments>http://comonad.com/reader/2009/incremental-folds/#comments</comments>
		<pubDate>Wed, 01 Apr 2009 04:12:04 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Squiggol]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2009/incremental-folds/</guid>
		<description><![CDATA[Recently, Sean Leather took up the idea of incremental folds. [1] [2]. At the end of his first article on the topic he made a comment on how this was a useful design pattern and sagely noted the advice of Jeremy Gibbons that design patterns are more effective as programs, while complaining of cut and [...]]]></description>
			<content:encoded><![CDATA[<p>Recently, Sean Leather took up the idea of incremental folds. <a href="http://splonderzoek.blogspot.com/2009/02/incremental-fold-design-pattern.html">[1]</a> <a href="http://splonderzoek.blogspot.com/2009/03/incremental-attributes.html">[2]</a>. At the end of his first article on the topic he made a comment on how this was a useful design pattern and sagely noted the advice of Jeremy Gibbons that design patterns are more effective as programs, while complaining of cut and paste coding issues. </p>
<p>The following attempts to address these concerns. </p>
<p><span id="more-83"></span></p>
<p>Below, I'm going to be using two libraries which I haven't mentioned on here before:</p>
<ul>
<li>
My <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monoids">monoids</a> library which contains among other things a large supply of monoids and the concept of a <a href="http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Reducer.html">Reducer</a>. A 'Reducer' is a monoid that knows how to inject values from another type. It also supports efficient left-to-right and right-to-left reduction, but we will be availing ourselves of neither of those extra faculties at the moment.
</li>
<li>
The other library is <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/reflection">reflection</a>, which is a transcoding of Oleg Kiselyov and Chung-chieh Shan's incredibly elegant approach from <a href="http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf">"Functional Pearl: Implicit Configurations"</a> updated slightly to work with the changes in GHC's implementation of ScopedTypeVariables since the article was written.
 </li>
</ul>
<p>The source code for this post is available as <a href="http://comonad.com/haskell/Incremental.hs">Incremental.hs</a>.</p>
<p>The 'monoids' and 'reflection' libraries are available from hackage.</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">{-# LANGUAGE
   TypeOperators
 , MultiParamTypeClasses
 , FlexibleInstances
 , FlexibleContexts
 , UndecidableInstances
 , ScopedTypeVariables
 , GeneralizedNewtypeDeriving
 #-}</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">module</span> Incremental <span style="color: #06c; font-weight: bold;">where</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">import</span> Text.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Text.<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a>
<span style="color: #06c; font-weight: bold;">import</span> Data.Reflection
<span style="color: #06c; font-weight: bold;">import</span> Data.Monoid.Reducer <span style="color: #06c; font-weight: bold;">hiding</span> <span style="color: green;">&#40;</span>Sum,getSum,cons,ReducedBy<span style="color: green;">&#40;</span>Reduction,getReduction<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>[Edit: updated to hide a few more things from Data.Monoid.Reducer which now contains a 'ReducedBy' constructor, which serves a different purpose.]</p>
<p>I want to take a bit of a different tack than I did with 'category-extras' and define algebras and coalgebras as type classes.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; Algebra f m <span style="color: #06c; font-weight: bold;">where</span>
    phi :: f m -&gt; m
&nbsp;
<span style="color: #06c; font-weight: bold;">class</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; Coalgebra f m <span style="color: #06c; font-weight: bold;">where</span>
    psi :: m -&gt; f m
&nbsp;</pre>
<p>This means that if you need to use a different Algebra, apply a newtype wrapper to the value m. We'll fix this requirement to some degree later on in this post.</p>
<p>Now, for every Functor, we can reduce it to ().</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; Algebra f <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi _ = <span style="color: green;">&#40;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>And we can define the idea of an F-Algebra product</p>
<pre class="haskell">&nbsp;
<span style="color: #5d478b; font-style: italic;">-- F-Algebra product</span>
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Algebra f m, Algebra f n<span style="color: green;">&#41;</span> =&gt; Algebra f <span style="color: green;">&#40;</span>m,n<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi a = <span style="color: green;">&#40;</span>phi <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fst"><span style="font-weight: bold;">fst</span></a> a<span style="color: green;">&#41;</span>, phi <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:snd"><span style="font-weight: bold;">snd</span></a> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>Algebra f m, Algebra f n, Algebra f o<span style="color: green;">&#41;</span>
  =&gt; Algebra f <span style="color: green;">&#40;</span>m,n,o<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi a = <span style="color: green;">&#40;</span>phi <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f a<span style="color: green;">&#41;</span>,phi <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> g a<span style="color: green;">&#41;</span>,phi <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
        f <span style="color: green;">&#40;</span>x,_,_<span style="color: green;">&#41;</span> = x
        g <span style="color: green;">&#40;</span>_,y,_<span style="color: green;">&#41;</span> = y
        h <span style="color: green;">&#40;</span>_,_,z<span style="color: green;">&#41;</span> = z
&nbsp;</pre>
<p>and so on for larger tuples.</p>
<p>From there, the usual direction would be to define a fixpoint operator in one of several ways, so not to disappoint:</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Mu f = In <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    In f == In g = f == g
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    In f `<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a>` In g = f `<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a>` g
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    showsPrec d <span style="color: green;">&#40;</span>In f<span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showParen"><span style="font-weight: bold;">showParen</span></a> <span style="color: green;">&#40;</span>d &gt; <span style="color: red;">10</span><span style="color: green;">&#41;</span> $
        <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showString"><span style="font-weight: bold;">showString</span></a> <span style="color: #3c7331;">&quot;In &quot;</span> . showsPrec <span style="color: red;">11</span> f
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    readPrec = parens . prec <span style="color: red;">10</span> $ <span style="color: #06c; font-weight: bold;">do</span>
        Ident <span style="color: #3c7331;">&quot;In &quot;</span> &lt; - lexP
        f &lt;- step readPrec
        <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> <span style="color: green;">&#40;</span>In f<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Now, we can define an Algebra and Coalgebra for getting into and out of this fixed point.</p>
</pre>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; Algebra f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi = In
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; Coalgebra f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    psi <span style="color: green;">&#40;</span>In x<span style="color: green;">&#41;</span> = x
&nbsp;</pre>
<p>But our goal is an incremental fold without boilerplate. So I'd rather than the fixed point operator did the heavy lifting for me.</p>
<p>So lets define an alternative fixedpoint, in which we'll carry around an extra term for the result of applying the incremental Algebra so far.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> = f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> :&gt; m
&nbsp;</pre>
<p>The much more categorically inclined members of the audience may recognize that immediately as the 'cofree' comonad of f from category-extras, and in fact we could continue on adding that definition, and turn it into a comonad for any Functor. I leave that as an exercise for the interested reader, but what we are interested in is the 'extract' operation of that comonad, which we'll just call value for now.</p>
<pre class="haskell">&nbsp;
value :: <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> -&gt; m
value <span style="color: green;">&#40;</span>_ :&gt; m<span style="color: green;">&#41;</span> = m
&nbsp;</pre>
<p>The particularly observant may further note that value itself is an (f :>)-algebra, since the 'extract' operation of any copointed functor f is just an f-algebra.</p>
<p>First, we add some boilerplate in the fashion of Mu f above.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> m, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a> <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    f :&gt; m == g :&gt; n = f == g &amp;&amp; m == n
    f :&gt; m /= g :&gt; n = f /= g || m /= n
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> m, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a> <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> `<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a>` <span style="color: green;">&#40;</span>g :&gt; n<span style="color: green;">&#41;</span> | a == EQ = m `<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a>` n
                                | <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:otherwise"><span style="font-weight: bold;">otherwise</span></a> = a
        <span style="color: #06c; font-weight: bold;">where</span> a = f `<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:compare"><span style="font-weight: bold;">compare</span></a>` g
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> m, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a> <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    showsPrec d <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showParen"><span style="font-weight: bold;">showParen</span></a> <span style="color: green;">&#40;</span>d &gt; <span style="color: red;">9</span><span style="color: green;">&#41;</span> $
        showsPrec <span style="color: red;">10</span> f .
        <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:showString"><span style="font-weight: bold;">showString</span></a> <span style="color: #3c7331;">&quot; :&gt; &quot;</span> .
        showsPrec <span style="color: red;">10</span> m
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> m, <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a> <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    readPrec = parens $ prec <span style="color: red;">9</span> $ <span style="color: #06c; font-weight: bold;">do</span>
            f &lt; - step readPrec
            Symbol <span style="color: #3c7331;">&quot;:&gt;&quot;</span> &lt; - lexP
            m &lt;- step readPrec
            <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return"><span style="font-weight: bold;">return</span></a> <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>and then we note that we can ask for the 'tail' of any cofree comonad as well, which gives us a more immediately useful coalgebra.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; Coalgebra f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    psi <span style="color: green;">&#40;</span>x :&gt; _<span style="color: green;">&#41;</span> = x
&nbsp;</pre>
<p>And now, we come back to why we made algebras and coalgebras into a typeclass in the first place. We can define an algebra for how we propagate the information from another algebra that we want to incrementally apply to our functor f. </p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Algebra f m =&gt; Algebra f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi x = x :&gt; phi <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> value x<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>We can give these convenient names so we don't get our phi's and psi's confused.</p>
<pre class="haskell">&nbsp;
forget :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> -&gt; f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span>
forget = psi
&nbsp;
remember :: Algebra f m =&gt; f <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> -&gt; f :&gt; m
remember = phi
&nbsp;</pre>
<p>'forget' discards the wrapper which contains the result of having applied our algebra.</p>
<p>'remember' takes an f (f :> m) and adds a wrapper, which remembers the result of having applied our selected f-algebra with carrier m.</p>
<p>With these convenient aliases, we can define catamorphisms and anamorphisms over (f :> m).</p>
<pre class="haskell">&nbsp;
cata :: Algebra f a =&gt; <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> -&gt; a
cata = phi . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> cata . forget
&nbsp;
ana :: <span style="color: green;">&#40;</span>Algebra f m, Coalgebra f a<span style="color: green;">&#41;</span> =&gt; a -&gt; <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span>
ana = remember . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> ana . psi
&nbsp;</pre>
<p>cata just forgets the wrapper, and applies an algebra recursively as usual.</p>
<p>On the other hand, our anamorphism now needs to know the algebra for the incremental fold, so that it can apply it as it builds up our new structure.</p>
<p>We can easily go back and forth between our two fixed point representations.</p>
<pre class="haskell">&nbsp;
tag :: Algebra f m =&gt; Mu f -&gt; <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span>
tag = remember . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> tag . psi
&nbsp;
untag :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>f :&gt; m<span style="color: green;">&#41;</span> -&gt; Mu f
untag = phi . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> untag . forget
&nbsp;</pre>
<p>Now, with that machinery in hand, lets try to build a couple of examples, and then see if we can push the envelope a little further.</p>
<p>So lets define the binary tree that Sean has been using, except now as a base functor that we'll fold.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> Tree a r = Bin r a r | Tip
    <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>Tree a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>Bin x a y<span style="color: green;">&#41;</span> = Bin <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span> a <span style="color: green;">&#40;</span>f y<span style="color: green;">&#41;</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> _ Tip = Tip
&nbsp;</pre>
<p>As with Sean's code, we'll use a pair of smart constructors to build our tree, but note, we no longer have the unsightly and easily mistaken explicit algebra arguments. You can no longer mistakenly apply the wrong algebra!</p>
<pre class="haskell">&nbsp;
bin :: Algebra <span style="color: green;">&#40;</span>Tree a<span style="color: green;">&#41;</span> m =&gt;
    <span style="color: green;">&#40;</span>Tree a :&gt; m<span style="color: green;">&#41;</span> -&gt; a -&gt; <span style="color: green;">&#40;</span>Tree a :&gt; m<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>Tree a :&gt; m<span style="color: green;">&#41;</span>
bin a v b = remember <span style="color: green;">&#40;</span>Bin a v b<span style="color: green;">&#41;</span>
&nbsp;
tip :: Algebra <span style="color: green;">&#40;</span>Tree a<span style="color: green;">&#41;</span> m =&gt; <span style="color: green;">&#40;</span>Tree a :&gt; m<span style="color: green;">&#41;</span>
tip = remember Tip
&nbsp;</pre>
<p>And, we'll need some data to play with, so lets define a nice generic looking tree.</p>
<pre class="haskell">&nbsp;
testTree :: <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a, Algebra <span style="color: green;">&#40;</span>Tree a<span style="color: green;">&#41;</span> m<span style="color: green;">&#41;</span> =&gt; Tree a :&gt; m
testTree = bin tip <span style="color: red;">2</span> <span style="color: green;">&#40;</span>bin <span style="color: green;">&#40;</span>bin tip <span style="color: red;">3</span> tip<span style="color: green;">&#41;</span> <span style="color: red;">4</span> tip<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>And while we're at it lets define a couple of algebras to try things out.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Size = Size <span style="color: green;">&#123;</span> getSize :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: green;">&#125;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Algebra <span style="color: green;">&#40;</span>Tree a<span style="color: green;">&#41;</span> Size <span style="color: #06c; font-weight: bold;">where</span>
    phi <span style="color: green;">&#40;</span>Bin x _ y<span style="color: green;">&#41;</span> = x + <span style="color: red;">1</span> + y
    phi Tip = <span style="color: red;">0</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Sum = Sum <span style="color: green;">&#123;</span> getSum :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> <span style="color: green;">&#125;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a><span style="color: green;">&#41;</span>
<span style="color: #06c; font-weight: bold;">instance</span> Algebra <span style="color: green;">&#40;</span>Tree <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#41;</span> Sum <span style="color: #06c; font-weight: bold;">where</span>
    phi <span style="color: green;">&#40;</span>Bin x y z<span style="color: green;">&#41;</span> = x + Sum y + z
    phi Tip = <span style="color: red;">0</span>
&nbsp;</pre>
<p>With those we can now rush off to ghci and give it a whirl.</p>
<pre class="haskell">&nbsp;
*Incremental&gt; testTree :: Tree <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> :&gt; Sum
Bin
    <span style="color: green;">&#40;</span>Tip :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">0</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
    <span style="color: red;">2</span>
    <span style="color: green;">&#40;</span>Bin
        <span style="color: green;">&#40;</span>Bin
            <span style="color: green;">&#40;</span>Tip :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">0</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
            <span style="color: red;">3</span>
            <span style="color: green;">&#40;</span>Tip :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">0</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
            :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">3</span><span style="color: green;">&#125;</span>
        <span style="color: green;">&#41;</span>
        <span style="color: red;">4</span>
        <span style="color: green;">&#40;</span>Tip :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">0</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
        :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">7</span><span style="color: green;">&#125;</span>
    <span style="color: green;">&#41;</span> :&gt; Sum <span style="color: green;">&#123;</span>getSum = <span style="color: red;">9</span><span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>Note that each node in the tree is tagged with the accumulated result of our algebra.</p>
<p>Of course, since we also have an f-algebra with carrier Mu f, we can ask for that to be computed incrementally as well. </p>
<pre class="haskell">&nbsp;
*Incremental&gt; testTree :: Tree <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> :&gt; Mu <span style="color: green;">&#40;</span>Tree <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#41;</span>
Bin <span style="color: green;">&#40;</span>Tip :&gt; In Tip<span style="color: green;">&#41;</span> <span style="color: red;">2</span> <span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>Tip :&gt; In Tip<span style="color: green;">&#41;</span> <span style="color: red;">3</span> <span style="color: green;">&#40;</span>Tip :&gt; In Tip<span style="color: green;">&#41;</span>
:&gt; In <span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span> <span style="color: red;">3</span> <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: red;">4</span> <span style="color: green;">&#40;</span>Tip :&gt; In Tip<span style="color: green;">&#41;</span> :&gt; In <span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>In
<span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span> <span style="color: red;">3</span> <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: red;">4</span> <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> :&gt; In <span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span> <span style="color: red;">2</span> <span style="color: green;">&#40;</span>In
<span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>In <span style="color: green;">&#40;</span>Bin <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span> <span style="color: red;">3</span> <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> <span style="color: red;">4</span> <span style="color: green;">&#40;</span>In Tip<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Of course, this prints very poorly, but shares heavily as you can see below thanks to <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum">vacuum</a> by Matt Morrow. </p>
<p><img src="http://comonad.com/haskell/tree.gif"/></p>
<p>Now, defining Sum, and Size manually may be all well and good, and its sure a lot less work than it was before, but we can also just decide to lift almost any Monoid into an f-Algebra. Here is where we need the 'Reducer' concept from 'monoids' that was mentioned earlier.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> Mon m = Mon <span style="color: green;">&#123;</span> getMon :: m <span style="color: green;">&#125;</span> <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a>,Monoid<span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>a `Reducer` m<span style="color: green;">&#41;</span> =&gt; Algebra <span style="color: green;">&#40;</span>Tree a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Mon m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi <span style="color: green;">&#40;</span>Bin x v y<span style="color: green;">&#41;</span> = x `mappend` Mon <span style="color: green;">&#40;</span><a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:unit"><span style="font-weight: bold;">unit</span></a> v<span style="color: green;">&#41;</span> `mappend` y
    phi Tip = mempty
    <span style="color: #5d478b; font-style: italic;">-- where unit :: (a `Reducer`m) =&gt; a -&gt; m</span>
&nbsp;</pre>
<p>Of course, we're not limited to trees.</p>
<pre class="haskell">&nbsp;
&nbsp;
<span style="color: #06c; font-weight: bold;">data</span> List a r = Cons a r | Nil
    <span style="color: #06c; font-weight: bold;">deriving</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq"><span style="background-color: #efefbf; font-weight: bold;">Eq</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord"><span style="background-color: #efefbf; font-weight: bold;">Ord</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Show"><span style="background-color: #efefbf; font-weight: bold;">Show</span></a>,<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read"><span style="background-color: #efefbf; font-weight: bold;">Read</span></a><span style="color: green;">&#41;</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f <span style="color: green;">&#40;</span>Cons a x<span style="color: green;">&#41;</span> = Cons a <span style="color: green;">&#40;</span>f x<span style="color: green;">&#41;</span>
    <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> _ Nil = Nil
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Algebra <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> Size <span style="color: #06c; font-weight: bold;">where</span>
    phi <span style="color: green;">&#40;</span>Cons _ xs<span style="color: green;">&#41;</span> = <span style="color: red;">1</span> + xs
    phi Nil = <span style="color: red;">0</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> Algebra <span style="color: green;">&#40;</span>List <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#41;</span> Sum <span style="color: #06c; font-weight: bold;">where</span>
    phi <span style="color: green;">&#40;</span>Cons x xs<span style="color: green;">&#41;</span> = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fromIntegral"><span style="font-weight: bold;">fromIntegral</span></a> x + xs
    phi Nil = <span style="color: red;">0</span>
&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span>a `Reducer` m<span style="color: green;">&#41;</span> =&gt; Algebra <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>Mon m<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi <span style="color: green;">&#40;</span>Cons x xs<span style="color: green;">&#41;</span> = Mon <span style="color: green;">&#40;</span><a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Adjunction.html#v:unit"><span style="font-weight: bold;">unit</span></a> x<span style="color: green;">&#41;</span> `mappend` xs
    phi Nil = mempty
&nbsp;
cons :: Algebra <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> m =&gt; a -&gt; <span style="color: green;">&#40;</span>List a :&gt; m<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>List a :&gt; m<span style="color: green;">&#41;</span>
cons a b = remember <span style="color: green;">&#40;</span>Cons a b<span style="color: green;">&#41;</span>
&nbsp;
nil :: Algebra <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> m =&gt; List a :&gt; m
nil = remember Nil
&nbsp;
testList :: <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num"><span style="background-color: #efefbf; font-weight: bold;">Num</span></a> a, Algebra <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> m<span style="color: green;">&#41;</span> =&gt; List a :&gt; m
testList = cons <span style="color: red;">2</span> . cons <span style="color: red;">5</span> . cons <span style="color: red;">8</span> $ cons <span style="color: red;">27</span> nil
&nbsp;</pre>
<p>But now we're at a bit of an impasse. How do you deal with f-algebras that use some environment? When writing these out by hand, if a particular algebra uses a variable that is in scope it just closes over it in its environment. Giving a reference to the carrier for the algebra permits the abstraction to leak, and most likely requires you to regress to a smart constructor approach in which you package up that extra information by hand.</p>
<p>Since we package up the algebra in a type class, we seem, at first glance to have lost the ability to access an environment. After all a 'benefit' of the looser types permitted by Sean's post was that he could build values using an arbitrary algebra, just using any old pair of functions.</p>
<p>One useful example that would seem at first glance to be ruled out is the following. Every different filter function would have to be a different algebra!</p>
<pre class="haskell">&nbsp;
filter_phi ::
    Algebra <span style="color: green;">&#40;</span>List a<span style="color: green;">&#41;</span> m =&gt;
    <span style="color: green;">&#40;</span>a -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool"><span style="background-color: #efefbf; font-weight: bold;">Bool</span></a><span style="color: green;">&#41;</span> -&gt;
    List a <span style="color: green;">&#40;</span>List a :&gt; m<span style="color: green;">&#41;</span> -&gt; List a :&gt; m
filter_phi p Nil = nil
filter_phi p <span style="color: green;">&#40;</span>Cons a <span style="color: #06c; font-weight: bold;">as</span><span style="color: green;">&#41;</span>
    | p a = cons a <span style="color: #06c; font-weight: bold;">as</span>
    | <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:otherwise"><span style="font-weight: bold;">otherwise</span></a> = <span style="color: #06c; font-weight: bold;">as</span>
&nbsp;</pre>
<p>So, lets do just that. We need to be able to reify an arbitrary function from a term into a type and we can do this with Data.Reflection! For the technical details, please read Oleg and Chung-chieh's very elegant functional pearl, but the idea is that by carefully abusing the ability to convert a list of integers into a type, we can convert a stable pointer into a type and share it in a limited context. In this case, that stable pointer can point to our particular algebra, environment and all, and yet we can be sure that the user doesn't try to mix incremental folds that use different environments.</p>
<p>To do this, we need a phantom type parameter in the carrier for our f-algebra.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">newtype</span> <span style="color: green;">&#40;</span>a `ReducedBy` s<span style="color: green;">&#41;</span> = Reduction <span style="color: green;">&#123;</span> getReduction :: a <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>and to reflect the function back down from the type level in our f-algebra.</p>
<pre class="haskell">&nbsp;
<span style="color: #06c; font-weight: bold;">instance</span> <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f, s `Reflects` <span style="color: green;">&#40;</span>f a -&gt; a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> =&gt;
  Algebra f <span style="color: green;">&#40;</span>a `ReducedBy` s<span style="color: green;">&#41;</span> <span style="color: #06c; font-weight: bold;">where</span>
    phi = Reduction . reflect <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:undefined"><span style="font-weight: bold;">undefined</span></a> :: s<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> getReduction
&nbsp;</pre>
<p>With that we can define any f-algebra that needs context, by reflecting it into the type system. The rank-2 type protects us from trying to put together data structures that were constructed using different algebras.</p>
<p>So now we can now apply this particular algebra to filter a list incrementally build up a list which incrementally builds itself in the [Int] monoid and tracks its length. Here we'll filter the list from earlier for even numbers and apply these other incremental operations all in one go. It reads a little more naturally if broken into parts, but we can write this all in one go.</p>
<pre class="haskell">&nbsp;
test :: List <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> :&gt; <span style="color: green;">&#40;</span>Mon <span style="color: green;">&#91;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#93;</span>,Size<span style="color: green;">&#41;</span>
test = reify
    <span style="color: green;">&#40;</span>filter_phi <span style="color: green;">&#40;</span>\\x -&gt; x `<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:mod"><span style="font-weight: bold;">mod</span></a>` <span style="color: red;">2</span> == <span style="color: red;">0</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
    <span style="color: green;">&#40;</span>\\<span style="color: green;">&#40;</span>_ :: s<span style="color: green;">&#41;</span> -&gt;
      getReduction <span style="color: green;">&#40;</span>
        value <span style="color: green;">&#40;</span>
          testList :: List <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> :&gt;
            <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>List <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a> :&gt; <span style="color: green;">&#40;</span>Mon <span style="color: green;">&#91;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int"><span style="background-color: #efefbf; font-weight: bold;">Int</span></a><span style="color: green;">&#93;</span>,Size<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> `ReducedBy` s<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>Which we can test out:</p>
<pre class="haskell">&nbsp;
*Incremental&gt; test
Cons <span style="color: red;">2</span> <span style="color: green;">&#40;</span>
    Cons <span style="color: red;">8</span> <span style="color: green;">&#40;</span>
        Nil :&gt; <span style="color: green;">&#40;</span>Mon <span style="color: green;">&#123;</span>getMon = <span style="color: green;">&#91;</span><span style="color: green;">&#93;</span><span style="color: green;">&#125;</span>,Size <span style="color: green;">&#123;</span>getSize = <span style="color: red;">0</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
    <span style="color: green;">&#41;</span> :&gt; <span style="color: green;">&#40;</span>Mon <span style="color: green;">&#123;</span>getMon = <span style="color: green;">&#91;</span><span style="color: red;">8</span><span style="color: green;">&#93;</span><span style="color: green;">&#125;</span>,Size <span style="color: green;">&#123;</span>getSize = <span style="color: red;">1</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
<span style="color: green;">&#41;</span> :&gt; <span style="color: green;">&#40;</span>Mon <span style="color: green;">&#123;</span>getMon = <span style="color: green;">&#91;</span><span style="color: red;">2</span>,<span style="color: red;">8</span><span style="color: green;">&#93;</span><span style="color: green;">&#125;</span>,Size <span style="color: green;">&#123;</span>getSize = <span style="color: red;">2</span><span style="color: green;">&#125;</span><span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>And there you have an incremental fold upon reflection.</p>
<p>[<a href="http://comonad.com/haskell/Incremental.hs">Incremental.hs</a>]<br />
[<a href="http://comonad.com/haskell/reflection/Data/Reflection.hs">Data/Reflection.hs</a>]<br />
[<a href="http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Reducer.html">Data/Monoid/Reducer.hs</a>]</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2009/incremental-folds/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Elgot (Co)Algebras</title>
		<link>http://comonad.com/reader/2008/elgot-coalgebras/</link>
		<comments>http://comonad.com/reader/2008/elgot-coalgebras/#comments</comments>
		<pubDate>Tue, 20 May 2008 02:31:26 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Comonads]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Mathematics]]></category>
		<category><![CDATA[Monads]]></category>
		<category><![CDATA[Squiggol]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/elgot-algebras/</guid>
		<description><![CDATA[&#160;
&#62; import Control.Arrow &#40;&#40;&#124;&#124;&#124;&#41;,&#40;&#38;&#38;&#38;&#41;,left&#41;
&#62; newtype Mu f = InF &#123; outF :: f &#40;Mu f&#41; &#125;
&#160;
I want to talk about a novel recursion scheme that hasn't received a lot of attention from the Haskell community and its even more obscure dual -- which is necessarily more obscure because I believe this is the first time [...]]]></description>
			<content:encoded><![CDATA[<pre class="haskell">&nbsp;
&gt; <span style="color: #06c; font-weight: bold;">import</span> Control.Arrow <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>|||<span style="color: green;">&#41;</span>,<span style="color: green;">&#40;</span>&amp;&amp;&amp;<span style="color: green;">&#41;</span>,left<span style="color: green;">&#41;</span>
&gt; <span style="color: #06c; font-weight: bold;">newtype</span> Mu f = InF <span style="color: green;">&#123;</span> outF :: f <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: green;">&#125;</span>
&nbsp;</pre>
<p>I want to talk about a novel recursion scheme that hasn't received a lot of attention from the Haskell community and its even more obscure dual -- which is necessarily more obscure because I believe this is the first time anyone has talked about it. </p>
<p><a href="http://www.iti.cs.tu-bs.de/~adamek/adamek.html">Jiri Admek</a>, <a href="http://www.iti.cs.tu-bs.de/~milius/">Stefan Milius</a> and <a href="http://math.feld.cvut.cz/velebil/">Jiri Velebil</a> have done a lot of work on <a href="http://arxiv.org/abs/cs/0609040">Elgot algebras</a>.  Here I'd like to translate them into Haskell, dualize them, observe that the dual can encode primitive recursion, and provide some observations.</p>
<p>You can kind of think an Elgot algebra as a hylomorphism that cheats.</p>
<pre class="haskell">&nbsp;
&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:elgot"><span style="font-weight: bold;">elgot</span></a> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>f b -&gt; b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> b <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; b
&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:elgot"><span style="font-weight: bold;">elgot</span></a> phi psi = h <span style="color: #06c; font-weight: bold;">where</span> h = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> ||| phi . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h<span style="color: green;">&#41;</span> . psi
&nbsp;</pre>
<p><span id="more-60"></span></p>
<p>If you look at the signature for a hylomorphism:</p>
<pre class="haskell">&nbsp;
&gt; hylo :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>f b -&gt; b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a -&gt; f a<span style="color: green;">&#41;</span> -&gt; a -&gt; b
&gt; hylo phi psi = h <span style="color: #06c; font-weight: bold;">where</span> h = phi . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h . psi
&nbsp;</pre>
<p>Then you can see that an Elgot algebra is basically a hylomorphism that is allowed to shortcircuit the infinite tower of fmaps and return an intermediate result directly.</p>
<p>In some sense you can say that the coalgebra-like side of the hylomorphism is no longer oblivious to the algebra used to deconstruct the intermediate result.</p>
<p>We can take the Elgot algebra and dualize it to get a novel construction where the algebra-like side is no longer oblivious to the coalgebra. This allows your algebra to cheat and just use the intermediate results constructed by the anamorphism to return an answer. I'll choose to call this co-(Elgot algebra) an Elgot coalgebra in the sequel.</p>
<pre class="haskell">&nbsp;
&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:coelgot"><span style="font-weight: bold;">coelgot</span></a> :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>a, f b<span style="color: green;">&#41;</span> -&gt; b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a -&gt; f a<span style="color: green;">&#41;</span> -&gt; a -&gt; b
&gt; <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:coelgot"><span style="font-weight: bold;">coelgot</span></a> phi psi = h <span style="color: #06c; font-weight: bold;">where</span> h = phi . <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> &amp;&amp;&amp; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h . psi<span style="color: green;">&#41;</span>
&nbsp;</pre>
<p>In a lot of ways an Elgot algebra resembles Vene and Uustalu's <a href="http://citeseer.ist.psu.edu/vene98functional.html">apomorphism</a>.</p>
<pre class="haskell">&nbsp;
&gt; apo :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; Mu f
&gt; apo psi = h <span style="color: #06c; font-weight: bold;">where</span> h = InF . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h . <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> . outF ||| psi<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a>
&nbsp;</pre>
<p>However, we have 'unfixed' the algebra to be used from InF to something more general and the layering of Either and f is different.</p>
<p>Now, a generalized apomorphism does something similar entangling two coalgebras, but the signature doesn't quite match up either, since a generalized apomorphism uses an F-coalgebras and an F-(b + _)-monadic coalgebra. </p>
<pre class="haskell">&nbsp;
&gt; g_apo :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>b -&gt; f b<span style="color: green;">&#41;</span> -&gt; <span style="color: green;">&#40;</span>a -&gt; f <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> b a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; Mu f
&gt; g_apo g f = h <span style="color: #06c; font-weight: bold;">where</span> h = InF . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h . <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Left"><span style="font-weight: bold;">Left</span></a> . g ||| f<span style="color: green;">&#41;</span> . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:Right"><span style="font-weight: bold;">Right</span></a>
&nbsp;</pre>
<p>Similarly a zygomorphism, or more generally a <a href="http://dbappl.cs.utwente.nl/Publications/PaperStore/db-utwente-0000003537.pdf">mutumorphism</a> entangles two algebras.</p>
<p>An Elgot algebra occupies a somewhat rare spot in the theory of constructive algorithmics or recursion schemes in that it while it mixes an algebra with a coalgebra like a hylomorphism or metamorphisms, it entangles them in a novel way.</p>
<p>If we specialize the Elgot algebra by fixing its algebra to InF we get:</p>
<pre class="haskell">&nbsp;
&gt; elgot_apo :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>a -&gt; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Either"><span style="background-color: #efefbf; font-weight: bold;">Either</span></a> <span style="color: green;">&#40;</span>Mu f<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>f a<span style="color: green;">&#41;</span><span style="color: green;">&#41;</span> -&gt; a -&gt; Mu f
&gt; elgot_apo psi = h <span style="color: #06c; font-weight: bold;">where</span> h = <span style="color: green;">&#40;</span><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id"><span style="font-weight: bold;">id</span></a> ||| InF . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> h<span style="color: green;">&#41;</span> . psi
&nbsp;</pre>
<p>We can see that the type is now closely related to that of an apomorphism with some slight changes in design decisions. Instead of wrapping a functor around further seeds, a, or a finished structure, this specialized Elgot algebra returns the finished structure directly or an f wrapped around seeds. </p>
<p><b>The Good</b></p>
<p>So can we convert between an apomorphism and an Elgot algebra? For a somewhat circuitous path to that answer lets recall the <a href="http://comonad.com/reader/2008/deriving-strength-from-laziness/">definition of strength</a> from my post a couple of weeks ago. Flipping the arguments and direction of application for strength to simplify what is coming we get:</p>
<pre class="haskell">&nbsp;
&gt; strength' :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; t -&gt; f a -&gt; f <span style="color: green;">&#40;</span>t, a<span style="color: green;">&#41;</span>
&gt; strength' fa b = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span><span style="color: green;">&#40;</span>,<span style="color: green;">&#41;</span>b<span style="color: green;">&#41;</span> fa
&nbsp;</pre>
<p>With that in hand we quickly find that we can rederive <a href="http://en.wikipedia.org/wiki/Paramorphism">paramorphisms</a> (and hence primitive recursion) from the novel notion of an Elgot coalgebra that we defined above by leaning on the strength of our functor.</p>
<pre class="haskell">&nbsp;
&gt; para :: <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor"><span style="background-color: #efefbf; font-weight: bold;">Functor</span></a> f =&gt; <span style="color: green;">&#40;</span>f <span style="color: green;">&#40;</span>Mu f, c<span style="color: green;">&#41;</span> -&gt; c<span style="color: green;">&#41;</span> -&gt; Mu f -&gt; c
&gt; para f = <a href="http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Algebra-Elgot.html#v:coelgot"><span style="font-weight: bold;">coelgot</span></a> <span style="color: green;">&#40;</span>f . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:uncurry"><span style="font-weight: bold;">uncurry</span></a> strength'<span style="color: green;">&#41;</span> outF
&nbsp;</pre>
<p>This result tells us that the shiny new Elgot coalgebras we defined above are strong enough to encode primitive recursion when working in Haskell.</p>
<p><b>The Bad</b></p>
<p>This tempts us to try to derive apomorphisms from Elgot algebras using the dual case, costrength. However, if you'll recall from my previous post on comonadic costrength, we can't do that in general. The result is only defined for Traversable functors; not every functor is costrong in Haskell!</p>
<p>Consequently and counterintuitively, though we can define a paramorphism in terms of Elgot coalgebras, we can only define an apomorphism in terms of Elgot algebras for traversable functors.</p>
<p><b>The Ugly</b></p>
<p>Now, worse news. Since the tower of functors we build up doesn't run off to infinity we lose the ability to generalize Elgot (co)algebras using the same machinery we can use to generalize the various traditional recursion schemes by parameterizing it by a (co)monad and distributive law.</p>
<p>At least the straightforward translation fails. For instance in the case of an Elgot algebra, the obvious addition would be to allow for the algebra (f a -> a) to be replaced with a F-W-comonadic algebra (f (w a) -> a) for some comonad w. However, attempts to do so run afoul of the fact that the coalgebra-like structure feeds us an 'a' not a 'w a'. We can of course change the signature of the coalgebra to give us the comonad, but the breakdown of modularity is unfortunate. </p>
<p>Similary, parameterizing the coalgebra-like structure with a monad requires the ability to distribute the monad over Either b to get to where it can apply the distributive law for the base functor f. Interestingly the Either monad works, which gives us ways to compose Elgot (co)algebras, but that is a story for another day.</p>
<p>As usual there is a tradeoff in expressivity in one area to compensate for gains in another, but this manner of entangling provides us with a new set of possibilities to explore.</p>
<p>Code for Elgot algebras and Elgot coalgebras has been included in <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras-0.50.3">category-extras</a> as of release 0.50.3 as <a href="http://comonad.com/haskell/category-extras/src/Control/Functor/Algebra/">Control.Functor.Algebra.Elgot</a>. </p>
<p>Now available from hackage.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/elgot-coalgebras/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>Just Fokkinga Abide</title>
		<link>http://comonad.com/reader/2008/just-fokkinga-abide/</link>
		<comments>http://comonad.com/reader/2008/just-fokkinga-abide/#comments</comments>
		<pubDate>Thu, 08 May 2008 00:46:12 +0000</pubDate>
		<dc:creator>Edward Kmett</dc:creator>
				<category><![CDATA[Category Theory]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[Squiggol]]></category>

		<guid isPermaLink="false">http://comonad.com/reader/2008/just-fokkinga-abide/</guid>
		<description><![CDATA[I did some digging and found the universal operations mentioned in the last couple of posts: unzip, unbizip and counzip were referenced as abide, abide and coabide -- actually, I was looking for something else, and this fell into my lap.
They were apparently named for a notion defined by Richard Bird back in:

R.S. Bird. Lecture [...]]]></description>
			<content:encoded><![CDATA[<p>I did some digging and found the universal operations mentioned in the last couple of posts: unzip, unbizip and counzip were referenced as abide<img src='http://comonad.com/latex/300409b3693d9c2ed5beb2965fbe1685.png' title='${}_F$' alt='${}_F$' align=absmiddle>, abide<img src='http://comonad.com/latex/413889d0ad4c3d54fdf97c23514425fc.png' title='${}_\dagger$' alt='${}_\dagger$' align=absmiddle> and coabide<img src='http://comonad.com/latex/300409b3693d9c2ed5beb2965fbe1685.png' title='${}_F$' alt='${}_F$' align=absmiddle> -- actually, I was looking for something else, and this fell into my lap.</p>
<p>They were apparently named for a notion defined by Richard Bird back in:</p>
<blockquote><p>
R.S. Bird. Lecture notes on constructive functional programming. In M. Broy, editor, Constructive Methods in Computing Science. International Summer School directed by F.L. Bauer [et al.], Springer Verlag, 1989. NATO Advanced Science Institute Series (Series F: Computer and System Sciences Vol. 55).
</p></blockquote>
<p>The notion can be summed up by defining that two binary operations <img src='http://comonad.com/latex/d3a4f1a022abad70b22f229066e6298c.png' title='$\varobar$' alt='$\varobar$' align=absmiddle> and <img src='http://comonad.com/latex/8fa00c513ba6b25363ef179c33823f50.png' title='$\varominus$' alt='$\varominus$' align=absmiddle> <b>abide</b> if for all a, b, c, d:</p>
<p><img src='http://comonad.com/latex/a585c81706e6dd15a998ace5f1dac664.png' title='$(a \varominus b) \varobar (c \varominus d) = (a \varobar c) \varominus (b \varobar d)$' alt='$(a \varominus b) \varobar (c \varominus d) = (a \varobar c) \varominus (b \varobar d)$' align=absmiddle>.</p>
<p>There is a cute pictorial explanation of this idea in <a href="http://dbappl.cs.utwente.nl/Publications/PaperStore/db-utwente-404F4540.pdf">Maarten Fokkinga's remarkably readable Ph.D dissertation</a> on p. 20.</p>
<p>The idea appears again on p.88 as part of the famous 'banana split' theorem, and then later on p90 the above names above are given along with the laws:</p>
<pre class="haskell">&nbsp;
<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f &amp;&amp;&amp; <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> g = unfzip . <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>f &amp;&amp;&amp; g<span style="color: green;">&#41;</span>
bimap f g &amp;&amp;&amp; bimap h j = unbizip . bimap <span style="color: green;">&#40;</span>f &amp;&amp;&amp; h<span style="color: green;">&#41;</span> <span style="color: green;">&#40;</span>g &amp;&amp;&amp; j<span style="color: green;">&#41;</span>
<a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> f ||| <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> g = <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap"><span style="font-weight: bold;">fmap</span></a> <span style="color: green;">&#40;</span>f ||| g<span style="color: green;">&#41;</span> . counfzip
&nbsp;</pre>
<p>That said the cases when the inverse operations exist do not appear to be mentioned in these sources.</p>
]]></content:encoded>
			<wfw:commentRss>http://comonad.com/reader/2008/just-fokkinga-abide/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
	</channel>
</rss>
